"use strict";(self.webpackChunkstablecraft_io=self.webpackChunkstablecraft_io||[]).push([[620],{1807:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"stablecoin-mechanics/peg-adjustment-logic","title":"Peg Adjustment Logic","description":"At the heart of every stablecoin is a promise: that 1 token","source":"@site/docs/stablecoin-mechanics/peg-adjustment-logic.mdx","sourceDirName":"stablecoin-mechanics","slug":"/stablecoin-mechanics/peg-adjustment-logic","permalink":"/kb/stablecoin-mechanics/peg-adjustment-logic","draft":false,"unlisted":false,"editUrl":"https://github.com/johnpottergr/stablecraft.io/edit/main/docs/stablecoin-mechanics/peg-adjustment-logic.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"peg-adjustment-logic","title":"Peg Adjustment Logic","sidebar_position":5},"sidebar":"kbSidebar","previous":{"title":"Smart Contract Risks","permalink":"/kb/stablecoin-mechanics/smart-contract-risks"},"next":{"title":"Web3.js Send USDC","permalink":"/kb/code-examples/web3js-send-USDC"}}');var i=n(4848),a=n(8453);const r={id:"peg-adjustment-logic",title:"Peg Adjustment Logic",sidebar_position:5},o=void 0,l={},c=[{value:"Different approaches to maintaining the peg",id:"different-approaches-to-maintaining-the-peg",level:4},{value:"Next up:",id:"next-up",level:3}];function d(e){const t={h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"At the heart of every stablecoin is a promise: that 1 token\nwill always be worth approximately $1. But market forces\ndon\u2019t always cooperate. Whether it\u2019s a spike in demand, a\nsudden selloff, or broader market volatility, stablecoins\nface constant pressure to maintain their peg. That\u2019s where\npeg adjustment logic comes in."}),"\n",(0,i.jsx)(t.h4,{id:"different-approaches-to-maintaining-the-peg",children:"Different approaches to maintaining the peg"}),"\n",(0,i.jsx)(t.p,{children:"Stablecoins use different strategies to correct price drift and hold their target value. For fiat-backed tokens like USDC or USDT, the peg is maintained by the ability to redeem tokens 1:1 for U.S. dollars."}),"\n",(0,i.jsx)(t.p,{children:"If the price dips below $1 on exchanges, traders can buy tokens cheaply, redeem them for full value, and profit from the difference\u2014an arbitrage process that pulls the price back up. The same process works in reverse: if a token trades above $1, users can deposit dollars, receive stablecoins, and sell them at a premium, increasing supply and balancing the price downward."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Collateralized stablecoins"})," like DAI maintain their peg\nthrough a more complex, rules-based system. When DAI drifts\ntoo far from $1, MakerDAO adjusts key parameters like\nstability fees (interest rates on loans), collateralization\nratios, or even adds/removes supported assets. These changes\nmake minting more or less attractive, nudging supply and\ndemand back into balance. Over time, the protocol fine-tunes\nthese settings to keep the peg as close to $1 as possible."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Algorithmic stablecoins"})," take an even more active approach.\nInstead of relying on collateral or redemptions, they use\nbuilt-in mechanisms to expand or contract the token supply.\nIf the price rises above $1, the system mints more tokens to\nincrease supply. If the price falls below $1, it removes\ntokens from circulation\u2014either by burning them or offering\nincentives to hold or convert them. Price adjustments are usually driven by smart contracts reacting to on-chain\nprice feeds (oracles), sometimes multiple times per day."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Hybrid stablecoins"}),"\u2014like Frax\u2014combine collateral with algorithmic mechanisms. In this setup, a portion of the peg is enforced through traditional backing, while the rest is managed by supply elasticity. The goal is to create a self-correcting system that doesn\u2019t rely fully on reserves or third parties."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Regardless of the model, the core principle is the same: peg adjustment logic uses market incentives and protocol rules to keep the token's value stable over time. The more efficient and credible the mechanism, the tighter the peg. But every model comes with trade-offs. Overcollateralized systems can be capital-inefficient. Algorithmic ones can be fragile during market stress. Even fiat-backed models depend on user trust in the issuer\u2019s reserves and redemption process."}),"\n",(0,i.jsx)(t.p,{children:"For users and developers, understanding how a stablecoin adjusts its peg is critical to evaluating its reliability. Does it rely on collateral, incentives, redemption, or code? Can it react quickly enough in a volatile market? And what happens if confidence breaks down?"}),"\n",(0,i.jsx)(t.p,{children:"Stable value is a moving target\u2014and stablecoins stay on it through constant adjustment, not blind automation."}),"\n",(0,i.jsx)(t.h3,{id:"next-up",children:"Next up:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Smart Contract Risks \u2013 How failures in logic or data can break the peg"}),"\n",(0,i.jsx)(t.li,{children:"Algorithmic Pegs \u2013 Dig deeper into elastic supply models"}),"\n",(0,i.jsx)(t.li,{children:"Choosing a Stablecoin \u2013 Evaluate different peg mechanisms based on your business needs"}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);